module PPerm where

import qualified Data.List as List

import Data.IntMap (IntMap,(!))
import qualified Data.IntMap as IntMap

import Data.IntSet (IntSet)
import qualified Data.IntSet as IntSet

import Math.Algebra.Group.PermutationGroup (Permutation,p,(.^))
import Math.Algebra.Group.PermutationGroup as Permutation (fromPairs)
import qualified Math.Algebra.Group.SchreierSims as Permutation (isMember)

import Automata (Reg)

type Perm = Permutation Reg
type PPerm = IntMap Reg

isMem :: [Perm] -> Perm -> Bool
-- ^ @isMem gs p@ is true just if @p@ is in the group generated by @gs@.
--   Assumes that gs does not contain any unsupported permutations (i.e. the identity).
isMem [] p = p == 1
isMem gs p = Permutation.isMember gs p 
               -- Permutation.isMember will fail if gs contains an unsupported permutation.


toPPerm :: [Reg] -> Perm -> PPerm
-- ^ @toPPerm rs p@ is the partial permutation with domain @rs@ obtained by viewing
--   @p@ as partial.  It is intended that @rs@ is exactly the domain of @p@, but 
--   is required as a parameter because it is not derivable from @p@ (@p@ omits fixpoints).
toPPerm rs p =
  List.foldr (\r pp -> IntMap.insert r (r .^ p) pp) IntMap.empty rs
  
compseq :: PPerm -> PPerm -> PPerm
-- ^ @s1 `compseq` s2@ is the sequential composition @s1@ then @s2@.
compseq p q =
  IntMap.foldWithKey comp IntMap.empty p
  where
    comp k a b =
      case IntMap.lookup a q of
        Nothing -> b
        Just x  -> IntMap.insert k x b

inverse :: PPerm -> PPerm
-- ^ @inverse s@ is the inverse of @s@.
inverse p =
  IntMap.foldWithKey (\k a b -> IntMap.insert (p ! k) k b) IntMap.empty p
  
remap :: Reg -> Reg -> PPerm -> PPerm
-- ^ @remap i j s@ is the largest partial permutation @s@ smaller than the function @s[i |-> j]@
remap i j =
  IntMap.insert i j . IntMap.filter (j /=)

dom :: PPerm -> [Reg]
-- ^ @dom s@ is the domain of definition of @s@
dom = IntMap.keys

rng :: PPerm -> [Reg]
-- ^ @rng s@ is the range of definition of @s@
rng = IntMap.elems

toPerm :: PPerm -> Perm
-- ^ @toPerm s@ is @s@ viewed as a permutation.  Requires that @s@ is a bijection.
toPerm = Permutation.fromPairs . IntMap.toList

ch :: [Reg] -> [PPerm] -> [Reg]
-- ^ @ch rs ss@, a subset of @rs@, is the characteristic set of partial permutations @ss@.
--   The parameter @rs@ is not necessary, but allows for optimisation.
ch rs fs =
  let clWeakRegs = fst (fix (weakRegs, IntSet.toList weakRegs))
  in IntSet.toList (IntSet.difference rsSet clWeakRegs) -- assumes toList returns sorted
  where
    rsSet = IntSet.fromList rs
    weakRegs   = IntSet.difference rsSet strongRegs
      where
        strongRegs = List.foldr insertPerm rsSet fs
        insertPerm f s =
          let s'  = IntSet.intersection (IntSet.fromList $ IntMap.elems f) s in
          IntSet.intersection (IntMap.keysSet f) s'

    oneStep x (all,fr) =
      List.foldr insFrontier (all, fr) fs
      where
        insFrontier f (all,fr)
          | Just y <- IntMap.lookup x f, IntSet.notMember y all = (IntSet.insert y all, y:fr)
        insFrontier f (all,fr) = (all, fr)

    fix (all,[]) = (all,[])
    fix (all,xs) =
      fix $ List.foldr oneStep (all,[]) xs
      
restrict :: [Reg] -> PPerm -> PPerm
-- ^ @restrict rs s@ is @s@ with domain restricted to @rs@.
restrict rs f =
  List.foldr checkReg IntMap.empty rs
  where
    checkReg r pp
      | Just s <- IntMap.lookup r f = IntMap.insert r s pp
    checkReg r pp = pp